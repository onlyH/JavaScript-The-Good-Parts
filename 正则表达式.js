var parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;
var url = 'http://www.ora.com:80/goodparts?q#fragment';
var result = parse_url.exec(url);
var names = ['url', 'scheme', 'slash', 'host', 'port', 'path', 'query', 'hash'];
var blanks = '      ';
for(var i = 0; i < names.length; i++) {
	console.log(names[i] + ':' + blanks.substring(names[i].length), result[i])
}
/*
url:    http://www.ora.com:80/goodparts?q#fragment
scheme: http
slash:  //
host:   www.ora.com
port:   80
path:   goodparts
query:  q
hash:   fragment
*/
//^字符表示此字符串的开始,指引exec不要跳过那些不像url的前缀
( ? : ([A - Za - z] + ): ) ?
//匹配一个协议名,(?..)表示一个非捕获型分组,后缀?表示这个分组是可选的,[...]表示一个字符类,A-Za-z包含26个大写和26个小写,(-)范围从A-Z,后缀+表示这个字符类会被匹配一次或多次,:会按字面进行匹配.
(\/{0,3})
	//\/表示应该匹配／(斜杠)来进行转义,{0,3}表示／会被匹配0次或者1-3次
	([0 - 9.\ - A - Za - z] + )
	//匹配一个主机名,由一个或者多个数字,字母,以及.或者-字符组成,-会被转义为\-以防止与表示范围的连字符相混淆

	( ? ::(\d + )) ?
	// 它是由一个前置：加上一个或多个数组而组成的序列，\d表示一个数组字符。
	( ? : \/([^?#]*))?
		// [^?#]以一个^开始，它表示这个类包含除？和#之外的所有字符，*表示这个字符类会被匹配0次或多次
		( ? : \ ? ([ ^ #] * )) ?
		// ？开始的可选分组，包含0个或多个非#字符
		$
		// 表示这个字符串的结束，保证这个URL的尾部没有其他更多的内容了

		// 一个匹配数字的正则表达式，数字可能由一个整数部分加上一个可选的负号，一个可选的小数部分和一个可选的指数部分
		var parse_number = /^-?\d+(?:\.\d*)?(?:e[+\-]?\d+)?$/i;
		var test = function(num) {
			console.log(parse_number.test(num));
		}
		test('1'); //true
		test('number'); //false
		test('89.6'); //true
		test('123.21.34.100') //false
		test('123.45E-67'); //true
		test('123.45D-67'); //false
		// i标识表示匹配字母时忽略大小写
		-
		？ //表示这个负号是可选的
		\d + //匹配一个数组，+指引它可以匹配一个或多个数字

		/**
		 * RegExp能设置3个标识，g,i,m，可以直接添加到RegExp字面量的末尾
		 * g：全局的
		 * i：大小写不敏感
		 * m：多行
		 * 
		 * 对象属性：
		 * global：如果标识g被使用，值为true
		 * ignoreCase：如果标识i被使用，true
		 * lastIndex：下一次exec匹配开始的索引，初始值为0
		 * multiline：如果标识m被使用，值为true
		 * source：正则表达式源码文件
		 */
		// 构造一个匹配js字符串的正则表达式对象
		var my_regexp = /"(?:\\.|[^\\\"])*"/g;
		//创建一个匹配js字符串的正则表达式
		var my_regexp = new RegExp("\"(?:\\\\.|[^\\\\\\\"])*\"", 'g');

		// 用正则表达式字面量创建RegExp对象共享同一个单例
		function make_a() {
			return /a/gi;
		}
		var x = make_a();
		var y = make_a(); x.lastIndex = 10; console.log(y.lastIndex); //10

		// 一个正则表达式分支包含一个或多个正则表达式序列，这些序列被|字符分隔，如果这些序列中的任何一项符合匹配条件，那么这个选择就被匹配，它尝试按顺序依次匹配这些序列项
		"into".match(/in|int/)
		// 会在into中匹配in，但他不会匹配int，因为in已成功匹配
		/*
		一个正则表达式序列包含一个或多个正则表达式因子，每个因子能选择是否跟随一个量词，这个量词决定着这个因子被允许出现的次数，如果没有制定这个量词，那么该因子只会被匹配一次。
		正则表达式因子可以是一个字符，一个由圆括号包围的组，一个字符类，或者是一个转义序列，除了控制字符和特殊字符以外，所有的字符都会被按照字面处理：
		\/[](){}?+*|.^$
		如果希望上面列出的字符按字面去匹配，那么必须要用一个\前缀来进行转义。\前缀不能使字母或数字字面化。
		一个未被转义的.会匹配除行结束符以外的任何字符。
		当lastIndex属性值为0时，一个未转义的^会匹配文本的开始，当指定了m标识时，他也能匹配结束符
		一个未转义的$将匹配文本的结束，当指定了m标识时，他也能匹配结束符
		 */
		/*
		反斜杠字符在真个表达式因子中，稍有不同：
		\d:[0-9]，匹配一个数字 \D:相反
		\s:unicode空白符的一个不完美子集 \S:相反
		\w:[0-9A-Z_a-z]\W:相反
		\b:被指定为一个字符界标识，方便用于对文本的字边界进行匹配
		\1:指向分组1所捕获到的文本的一个引用，能被再次匹配
		\2:指向分组2的引用
		\3:指向分组3的引用
		 */
		// 正则表达式来搜索文本中的重复的单词
		var doubled = /([A-Za-z\u00c0-\u1FFF\u2800-\uFFFD]+)\s+\1/gi;

		/*
		捕获型：
		一个捕获型分组是一个被包围在圆括号中的正则表达式的分支，任何匹配这个分组的字符都会被捕获，每个捕获型分组都被指定来一个数字，第一个捕获（的是分组1，第二个捕获（的是分组2
		非捕获型：
		非捕获型分组有一个（?:前缀。仅仅做简单的匹配，并不会捕获所匹配的文本，不会干扰捕获型分组的编号
		向前正向匹配：
		分组有一个（?=前缀。在这个组匹配后，文本会倒回到它开始的地方，实际上并不匹配任何东西，
		向前负向匹配：
		（?!前缀。匹配失败的时候它才继续向前进行匹配
		 */
		// 正则表达式字符集
		[!-\/:-@\[-`{-~]/ / 匹配任何一个ASCII特殊的字符[ ^ !-\/:-@\[-`{-~]/ / 相反
				// 正则表达式量词
				/
				www / 匹配的和 / w {
					3
				}
				/ 一样 {
					3,
					6
				}
				会匹配3， 4， 5 或6次， {
					3,
				}
				会匹配3次或更多次 ?
				=== {
					0,
					1
				}
				* === {
					0,
				} +
				=== {
					1,
				}